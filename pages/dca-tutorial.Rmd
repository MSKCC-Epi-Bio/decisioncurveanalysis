---
title: "DCA: Software Tutorial"
output: 
  html_document:
    toc: true
    toc_float: true
    includes: 
      in_header: "../assets/highlight/header.html"
    css: "../assets/highlight/styles/agate.min.css"
params:
  language: r
editor_options: 
  markdown: 
    wrap: sentence
---

<!-- <div class="center"> -->
<!--   <h1>Decision Curve Analysis</h1> -->
<!-- </div> -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, fig.height = 3, cache = TRUE, 
                     cache.lazy = FALSE, message = FALSE)
options(knitr.duplicate.label = "allow")
gtsummary::theme_gtsummary_compact()

library(dcurves)
library(tidyverse)
library(gtsummary)

add_tabset_codes <- function(chunk_label, eval = TRUE, echo = FALSE, 
                             message = FALSE, include = TRUE, 
                             language = params$language) {
  active_r <- ifelse(language %in% "r", "{.active}", "")
  active_stata <- ifelse(language %in% "stata", "{.active}", "")
  active_sas <- ifelse(language %in% "sas", "{.active}", "")
  active_python <- ifelse(language %in% "python", "{.active}", "")
  
  res <-
    knitr::knit_child(
      text = unlist(knitr::knit_expand('../templates/tabset-template.Rmd')),
      quiet = TRUE,
      envir = rlang::caller_env()
    )
  cat(res, sep = '\n')
}

.convert_chunks_to_script <- function(language =  params$language) {
  # convert language name to comment symbols
  comment_start <-
    switch(language,
           "sas" = "/*",
           "r" = "#",
           "stata" = "/*",
           "python" = "#")
  comment_end <-
    switch(language,
           "sas" = "*/",
           "r" = "",
           "stata" = "*/",
           "python" = "")
  extension <-
    switch(language,
           "sas" = ".sas",
           "r" = ".R",
           "stata" = ".do",
           "python" = ".py")
  
  readr::read_lines(here::here("rmd_chunks", paste0(language, "-chunks", extension))) %>%
    map_chr(
      ~ifelse(
        # edit lines that are the chunk names
        startsWith(., "## ----") & endsWith(., "-----"),
        # replace the ## with the start comment symbols
        str_replace(., "^##", fixed(comment_start)) %>% 
          # add end of comment symbol
          paste(comment_end) %>% 
          # remove language name
          str_replace(fixed(paste0(language, "-")), ""),
        .
      )
    ) %>%
    readr::write_lines(
      here::here("rmd_chunks", "chunks_as_scripts", paste0("dca-script", extension))
    )
}

# save rmd chunks as a script
.convert_chunks_to_script()

# create link to download scripts
extension <- switch(params$language, 
                    "sas" = ".sas", "r" = ".R", 
                    "stata" = ".do", "python" = ".py")
script_url <- 
  paste0(
    "https://github.com/MSKCC-Epi-Bio/decisioncurveanalysis/raw/main/rmd_chunks/chunks_as_scripts/",
    "dca-script", extension
  )
```

```{r, read_chunk, include=FALSE}
knitr::read_chunk("../rmd_chunks/r-chunks.R")
knitr::read_chunk("../rmd_chunks/stata-chunks.do")
knitr::read_chunk("../rmd_chunks/sas-chunks.sas")
knitr::read_chunk("../rmd_chunks/python-chunks.py")
```

Below we will walk through how to perform decision curve analysis for binary and time-to-event outcomes using **R**, **Stata**, **SAS**, and **Python**.
Code is provided for all languages and can be downloaded or simply copy and pasted into your application to see how it runs.
For simplicity's sake, however, we only show output from the R functions; although, naturally, output is very similar irrespective of programming language.  .

## Select a language

```{r, language-table, echo = FALSE}
tibble::tibble(
  r = list(gt::html('<a href="dca-tutorial-r.html"><img src="../assets/images/r-icon.png" height="100" /></a>')),
  stata = list(gt::html('<a href="dca-tutorial-stata.html"><img src="../assets/images/stata-icon.png" height="55" /></a>')),
  sas = list(gt::html('<a href="dca-tutorial-sas.html"><img src="../assets/images/sas-icon.png" height="55" /></a>')),
  python = list(gt::html('<a href="dca-tutorial-python.html"><img src="../assets/images/python-icon.png" height="55" /></a>')),
) |>
  gt::gt() |>
  gt::cols_label(
    r = gt::html('<b><a href="dca-tutorial-r.html"><font color="black">R</a></b>'),
    stata = gt::html('<b><a href="dca-tutorial-stata.html"><font color="black">Stata</a></b>'),
    sas = gt::html('<b><a href="dca-tutorial-sas.html"><font color="black">SAS</a></b>'),
    python = gt::html('<b><a href="dca-tutorial-python.html"><font color="black">Python</a></b>')
  ) |>
  gt::cols_width(everything() ~ gt::px(150)) |>
  gt::opt_table_lines("none") |>
  gt::tab_style(
    style = gt::cell_borders(
      sides = "top",
      color = "#000000",
      weight = gt::px(4)
    ),
    locations = gt::cells_column_labels(all_of(params$language))
  )
```

```{r, results='asis', echo = FALSE}
str_glue('<div style="text-align: center; margin-top: 20px;"><a href="{script_url}" download target="_blank"><b>Download DCA Code</b></a></div>')
```

## Install & Load

Use the scripts below to install the decision curve analysis functions and/or load them for use.

```{r, install, echo=FALSE, results='asis'}
add_tabset_codes("install", eval = FALSE)
```

## Binary Outcomes

### Motivating Example

We will be working with an example data set containing information about cancer diagnosis.
The data set includes information on `r nrow(df_binary)` patients who have recently discovered they have a gene mutation that puts them at a higher risk for harboring cancer.
Each patient has been biopsied and we know their cancer status.
It is known that older patients with a family history of cancer have a higher probability of harboring cancer.
A clinical chemist has recently discovered a marker that she believes can distinguish between patients with and without cancer.
We wish to assess whether or not the new marker does indeed distinguish between patients with and without cancer.
If the marker does indeed predict well, many patients will not need to undergo a painful biopsy.

### Data Set-up

We will go through step by step how to import your data, build models based on multiple variables, and use those models to obtain predicted probabilities.
The first step is to import your data, label the variables and produce a table of summary statistics.
The second step is  you'll want to begin building your model.
As we have a binary outcome (i.e. the outcome of our model has two levels: cancer or no cancer), we will be using a logistic regression model.

```{r, import_cancer, echo=FALSE, message = FALSE, results='asis'}
add_tabset_codes("import_cancer")
```

### Univariate Decision Curve Analysis

First, we want to confirm family history of cancer is indeed associated with the biopsy result.

```{r, model, echo=FALSE, message = FALSE, results='asis'}
add_tabset_codes("model")
```

Via logistic regression with cancer as the outcome, we can see that family history is related to biopsy outcome with odds ratio 2.32 (95% CI: 1.44, 3.71; p<0.001).
The decision curve analysis can help us address the clinical utility of using family history to predict biopsy outcome.

```{r, dca_famhistory, echo=FALSE, message = FALSE, results='asis'}
add_tabset_codes("dca_famhistory")
```

First, note that there are many threshold probabilities shown here that are not of interest.
For example, it is unlikely that a patient would demand that they had at least a 50% risk of cancer before they would accept a biopsy.
Let's do the decision curve analysis again, this time restricting the output to threshold probabilities a more clinically reasonable range.
We think it would be not make sense if a patient opted for biopsy if their risk of cancer was less than 5%; similarly, it would be irrational not to get a biopsy if risk was above 35%.
So we want to look at the range between 5% and 35%.
Because 5% is pretty close to 0%, we will show the range between 0% and 35%.

```{r, dca_famhistory2, echo=FALSE, message = FALSE, results='asis'}
add_tabset_codes("dca_famhistory2")
```

Now that the graph is showing a more reasonable range of threshold probabilities, let's assess the clinical utility of family history alone.
We can see here that although family history is significantly associated with biopsy outcome, it only adds value to a small range of threshold probabilities near 13% - 20%.
If your personal threshold probability is 15% (i.e. you would only undergo a biopsy if your probability of cancer was 15% or more), then family history alone can be beneficial in making the decision to undergo biopsy.
However, if your threshold probability is less than 13% or higher than 20%, then using family history to decide on biopsy has less benefit than choosing to biopsy or not biopsy respectively.
Hence, we would conclude that using family history to determine who to biopsy would help some patients but harm some others, and so should not be used in the clinic.

### Multivariable Decision Curve Analysis

#### Evaluation of New Models

We want to examine the value of a statistical model that incorporates family history, age, and the marker.
First, we will build the logistic regression model with all three variables, and then save  the predicted probability of having cancer based on the model.
Note that in our example data set, this variable actually already exists so it wouldn't be necessary to create the predicted probabilities once again.

```{r, model_multi, echo=FALSE, message = FALSE, results='asis'}
add_tabset_codes("model_multi")
```

We now want to compare our different approaches to cancer detection: biopsying everyone, biopsying no-one, biopsying on the basis of family history, or biopsying on the basis of a multivariable statistical model including the marker, age and family history of cancer.

```{r, dca_multi, echo=FALSE, message = FALSE, results='asis'}
add_tabset_codes("dca_multi")
```

The key aspect of decision curve analysis is to look at which strategy leads to the largest net benefit (i.e. the "highest" line), which in this example would correspond to the model that includes age, family history of cancer, and the marker.
It is clear that the statistical model has the highest net benefit across the entire range of threshold probabilities.
Accordingly, we would conclude that using the model to decide whether to biopsy a patient would lead to better clinical outcomes.

The decision curve for the model should in theory be a smooth curve with net benefit always going down (or staying the same) as you move from left to right.
But the curve is a bit bumpy and sometimes even increases a bit, a result of statistical noise.
Some researchers prefer to show a smoothed curve and there are two options for doing so.
First, you can add a smoother.
Note that different programs use different smoothers as there is no one smoother that is best in every situation.
As such, results of a smoothed curve should always be compared with the unsmoothed curve to ensure that it gives a fair representation of the data.

```{r, dca_smooth, echo=FALSE, message = FALSE, results='asis'}
add_tabset_codes("dca_smooth")
```

An alternative is to calculate net benefit at wider intervals.
By default, the software calculates net benefit at every 1% of threshold probability, but we this can cause artifacts unless the data set is very large.
You can specify instead to calculate net benefit every 5%. 

```